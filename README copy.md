# PSALM: Applying Proportional SAmpLing Strategy in Metamorphic Testing

## 1. Overview

This repository contains the official implementation of the experiments for the paper:

> **“PSALM: applying Proportional SAmpLing strategy in Metamorphic testing”**

The codebase is research-oriented and focuses on:

- Implementing **PSALM** (a proportional sampling strategy) and baseline methods (Random, ART, MT-ART) for multiple subject programs.
- Executing **metamorphic testing experiments** against **mutant sets** generated by external mutation tools (see Section 6).
- Aggregating results into **raw JSON metrics** and **RQ-level Excel/figure/table artifacts** for the paper’s research questions RQ1–RQ3.

The repository is **not** designed as a single end-user tool or library:

- Experiments are organized around multiple **Java** and **Python** subject programs.
- Many components expose their own `main` or `if __name__ == "__main__":` entry points, but
  **there is no single unified entry point** that “runs the whole paper” end to end.
- Reproducing the full experimental pipeline requires **code-level understanding** in combination with the paper.

---

## 2. Background: PSALM and the Role of Mutants

**PSALM** applies a **Proportional Sampling** strategy in the context of metamorphic testing:

- Input domains are partitioned according to domain knowledge or prior work.
- Sampling probabilities are proportional to partition “sizes” or weights, rather than uniform.
- In this repository, PSALM is concretely realized by **partition-based generators**, e.g.:
  - `python/geometricSum/generation/phase1/partition_generator.py:10–27`
  - `java/src/main/java/paper/pss/exp/jackson_project/raw_results/get_raw_results_multithreaded.java:225–255` (via phase1/phase2 partition generators)

**Mutants** serve as **intermediate artifacts** to evaluate testing strategies:

- Mutants are used to measure **P-measure**–style detection probabilities for PSALM vs. baselines.
- Mutant sets are **not** the final product of this repository; they are **input** to experiments.

Mutants are **not generated inside this codebase**:

- Mutants are produced by **mature external mutation tools**, as described in the paper.
- Java utilities such as `RenameMutants` and `changePackagename` help integrate externally generated mutants into the expected package structure, e.g.:
  - `java/src/main/java/paper/pss/exp/utils/RenameMutants.java:18–23`
  - `java/src/main/java/paper/pss/exp/utils/changePackagename.java:16–19`
- Code in this repo **assumes** that mutant classes/functions already exist in appropriate locations (e.g. `.../mutants/`) and focuses on **loading, organizing, and using** them.

Without these mutants, the experiment and evaluation pipeline **cannot be run**; this is an explicit design premise for the research code.

---

## 3. Repository Structure

Top-level layout:

- `java/`  
  Maven project hosting Java subject programs, metamorphic relations, PSALM/baseline generators, mutant integration, and raw result scripts for Java subjects. See Section 4.
- `python/`  
  Python implementations for three numeric subjects (`geometricSum`, `incomeTax`, `mortgageRate`), including PSALM/baseline generators, mutant integration, and raw result scripts. See Section 5.
- `RQ1/`, `RQ2/`, `RQ3/`  
  Python analysis scripts and configuration files for the three research questions:
  - `RQ1/RQ1.py` compares PSALM vs Random (`partition` vs `random`) across projects and phases.
  - `RQ2/RQ2.py` compares PSALM between **phase1** (source test selection) and **phase2** (MG selection).
  - `RQ3/RQ3.py` compares PSALM vs **ART** and **MT-ART** (`P-measure_partition.json` vs `P-measure_art.json` / `P-measure_mtart.json`).
- `LICENSE`  
  MIT License (see Section 10).
- `README.md`  
  This document.

Subject programs and their language:

- Java subjects: `jackson_project`, `jfreeChart_project`, `lang_project`, `math1_project`, `math2_project` under `java/src/main/java/paper/pss/exp/`.
- Python subjects: `geometricSum`, `incomeTax`, `mortgageRate` under `python/`.

Each subject (Java or Python) has a **parallel directory structure**:

- `generation/phase1` and `generation/phase2` (PSALM & baselines).
- `metamorphicRelations/` (metamorphic relation definitions).
- `model/` (test case, metamorphic relation, metamorphic group models).
- `mutants/` (externally generated mutants, wrapped or imported here).
- `mutants_analysis/` (mutant classification / subsumption analysis).
- `raw_results/` (PSALM & baseline experiment drivers and JSON outputs).
- `utils/` (configuration parsing, path utilities, MG domain constructors, MR factories, etc.).

Raw experiment outputs for the RQs are stored as JSON under each subject’s `raw_results/`, and then aggregated by `RQ1/2/3` scripts.

---

## 4. Java Components

Java code lives under `java/src/main/java/paper/pss/exp/` and is organized by subject:

- `jackson_project/`
- `jfreeChart_project/`
- `lang_project/`
- `math1_project/`
- `math2_project/`
- `utils/` (shared utilities for integrating mutants)

### 4.1 Per-project layout

Taking `math1_project` as a representative example (others follow the same pattern):

- `model/`
  - `TestCase.java`  
    Encapsulates subject-specific inputs (here, two arrays and a partition id) used by generators and MRs  
    `java/src/main/java/paper/pss/exp/math1_project/model/TestCase.java:5–26`.
  - `MetamorphicRelation.java`  
    Defines the MR interface and its responsibilities: ID, description, follow-up generation, verification, applicability, and MR-group construction  
    `java/src/main/java/paper/pss/exp/math1_project/model/MetamorphicRelation.java:27–83`.
  - `MetamorphicGroup.java`  
    Bundles a single source and follow-up test case together with MR metadata, used throughout PSALM/MT-ART pipelines  
    `java/src/main/java/paper/pss/exp/math1_project/model/MetamorphicGroup.java:6–20`.
  - Some projects add additional models (e.g. `MutantResult`) specific to the subject.

- `metamorphicRelations/`
  - `MR1_relation.java`, `MR2_relation.java`, …  
    Concrete metamorphic relations for the subject under test (e.g., commutativity, associativity, scaling). Each implements `MetamorphicRelation` and encodes how to generate follow-up test cases and how to verify the relation.

- `generation/phase1/` and `generation/phase2/`  
  (Not fully listed in the directory snapshot but imported in raw-result drivers.)
  - Phase 1 generators produce **source test cases**, e.g.:
    - Random (`phase1_random_generator`)
    - Proportional/partition-based (PSALM, often `phase1_partition_generator`)
    - ART (`phase1_art_generator`)
  - Phase 2 generators operate on **metamorphic groups**:
    - Random MG selection (`phase2_random_generator`)
    - PSALM partition-based MG sampling (`phase2_partition_generator`)
    - MT-ART MG sampling (`phase2_mtart_generator`)
  - These classes are wired into experiments such as  
    `java/src/main/java/paper/pss/exp/jackson_project/raw_results/get_raw_results_multithreaded.java:16–21, 223–295`.

- `mutants/`
  - Contains directories like `mutantXX/` or `caseStudyYY/`, each representing a mutant variant of the target method.
  - Java code assumes a naming convention such as `paper.pss.exp.jackson_project.mutants.<mutantName>.parseInt`, and loads these via reflection, e.g.:  
    `java/src/main/java/paper/pss/exp/jackson_project/raw_results/get_raw_results_multithreaded.java:116–120`  
    `java/src/main/java/paper/pss/exp/jackson_project/mutants_analysis/MutantAnalysis.java:124–127`.
  - The mutants are **not generated here**; see Section 6 for how they are integrated.

- `mutants_analysis/`
  - `MutantAnalysis.java` implements:
    - Test-case generation for mutant analysis (`generateTestCases`)  
      `java/src/main/java/paper/pss/exp/jackson_project/mutants_analysis/MutantAnalysis.java:67–71`.
    - Batch execution of all mutants on generated test cases, constructing MGs via MR factories and checking MR violations  
      `MutantAnalysis.executeAllTests`  
      `java/src/main/java/paper/pss/exp/jackson_project/mutants_analysis/MutantAnalysis.java:108–176`.
    - Classification of mutants into **NORMAL**, **EQUIVALENT**, **SUBSUMED**, **ALLKILLED**, **ERROR**, **TIMEOUT** based on kill sets  
      `MutantAnalysis.analyzeMutants`  
      `java/src/main/java/paper/pss/exp/jackson_project/mutants_analysis/MutantAnalysis.java:213–296`.
    - Greedy computation of a **maximum independent set** of mutants based on subsumption relationships  
      `MutantAnalysis.calculateMaximumIndependentSet`  
      `java/src/main/java/paper/pss/exp/jackson_project/mutants_analysis/MutantAnalysis.java:301–317`.
    - JSON and CSV report generation over the mutant types and relations  
      `MutantAnalysis.generateReport` and `saveResults`  
      `java/src/main/java/paper/pss/exp/jackson_project/mutants_analysis/MutantAnalysis.java:383–520`.
    - A standalone `main` method for targeted mutant analysis runs (not a global entry point)  
      `MutantAnalysis.main`  
      `java/src/main/java/paper/pss/exp/jackson_project/mutants_analysis/MutantAnalysis.java:526–553`.

- `raw_results/`
  - `get_raw_results.java` / `get_raw_results_multithreaded.java` implement **PSALM vs baseline** experiments on mutants:
    - They configure **phase** (`phase1` / `phase2`), **strategies** (e.g. `"phase1.random"`, `"phase1.partition"`, `"phase1.art"`, `"phase2.random"`, `"phase2.partition"`, `"phase2.mtart"`), and test-case budgets.
    - For each mutant and each strategy, they:
      - Generate test cases or MGs using the phase-specific generator interfaces  
        `get_raw_results_multithreaded.initializeGenerators`  
        `java/src/main/java/paper/pss/exp/jackson_project/raw_results/get_raw_results_multithreaded.java:220–295`.
      - Compute **P-measure**: probability of defect detection via MR violations  
        `calculatePMeasure`  
        `java/src/main/java/paper/pss/exp/jackson_project/raw_results/get_raw_results_multithreaded.java:325–378`.
      - Store results as nested maps `{mutant -> {numTests -> [p_measure_runs]}}`.
    - `runExperimentMultithreaded` orchestrates per-mutant experiments in parallel and aggregates results  
      `java/src/main/java/paper/pss/exp/jackson_project/raw_results/get_raw_results_multithreaded.java:404–455`.
    - `saveResults` writes out `P-measure_<strategy>_multithreaded.json` under `raw_results/<phase>/`  
      `java/src/main/java/paper/pss/exp/jackson_project/raw_results/get_raw_results_multithreaded.java:460–479`.
    - A `main` method configures realistic experimental parameters and runs all strategies for the selected mutants  
      `get_raw_results_multithreaded.main`  
      `java/src/main/java/paper/pss/exp/jackson_project/raw_results/get_raw_results_multithreaded.java:568–648`.

- `utils/`
  - `MGDomainGenerator_utils.java` (per project) constructs a domain of metamorphic groups used in phase2 experiments.
  - `MRFactory_utils.java` (per project) creates the applicable MR set and provides helper methods such as `getApplicableRelations` and `getRelationById` used by experiment drivers  
    e.g. `java/src/main/java/paper/pss/exp/jackson_project/raw_results/get_raw_results_multithreaded.java:336–337, 364–365`.
  - `*ConfigExtractor_utils.java` parse project-specific configuration files (partitions, ratios, input ranges).

### 4.2 Cross-project utilities

- `paper.pss.exp.utils.RenameMutants`  
  Renames directories (e.g. numeric IDs → `mutantNN`) and injects correct package statements into externally generated mutant files, then mirrors file contents into the new layout and optionally deletes old directories  
  `java/src/main/java/paper/pss/exp/utils/RenameMutants.java:18–89`.
- `paper.pss.exp.utils.changePackagename`  
  Walks a mutant tree and adjusts Java package declarations from an “original test” namespace (e.g. `math2_test`) to the experimental one (`math2_project`)  
  `java/src/main/java/paper/pss/exp/utils/changePackagename.java:16–19, 32–63`.

These utilities highlight that **mutant generation happens elsewhere**; the Java code here is responsible for reorganizing and consuming mutants, not creating them.

---

## 5. Python Components

Python code lives under `python/` and is organized into three main subjects:

- `python/geometricSum/`
- `python/incomeTax/`
- `python/mortgageRate/`

Each subject mirrors the Java projects conceptually, with language-appropriate design.

### 5.1 Common structure across Python subjects

#### `generation/phase1` and `generation/phase2`

- Phase 1 generators produce **source test cases**:
  - Example (geometric sum ART generator):  
    `python/geometricSum/generation/phase1/art_generator.py:9–24, 30–50`  
    Implements a distance-based ART scheme over the configured input range.
  - PSALM (partition) generator:  
    `python/geometricSum/generation/phase1/partition_generator.py:10–27, 56–74`  
    Uses partition ratios (`partition_ratio`) and a maximin-like allocation to sample proportionally from partitions.

- Phase 2 generators produce **metamorphic groups**:
  - In Python subjects, MG-domain construction is centralized in utilities (see below), and phase2 generators consume that domain for PSALM, random, or MT-ART-like strategies.

#### `metamorphicRelations/`

- Defines concrete MRs used in experiments.
- Example (geometric sum MR1):  
  `python/geometricSum/metamorphicRelations/mr1_relation.py:7–22, 23–47, 49–66`  
  Encodes an MR relating `x` and `x*x/2` and verifies an inequality on the SUT outputs.

#### `model/`

- `metamorphic_relation.py` defines the abstract base class for MRs and a factory for assembling them:
  - Abstract interface for IDs, descriptions, follow-up generation, verification, and applicability  
    `python/geometricSum/model/metamorphic_relation.py:8–78`.
  - `create_groups` helper that constructs `MetamorphicGroup` instances from a source test case  
    `python/geometricSum/model/metamorphic_relation.py:80–109`.
  - `MetamorphicRelationFactory` and helpers to instantiate all MR classes and generate MR-based groups for a test case  
    `python/geometricSum/model/metamorphic_relation.py:115–171`.

- `metamorphic_group.py` models an MR group with a source and follow-up test case  
  `python/geometricSum/model/metamorphic_group.py:1–27, 29–43`.

- `test_case.py` (per subject) encapsulates subject-specific inputs and partition IDs.

#### `mutants/`

- `origin.py` holds the **original (non-mutated) SUT** implementation for each subject.
- `mutants.py` (for Python subjects) typically exposes a `mutants()` wrapper that collects mutant functions into a dictionary such as `test_subject`, used by experiments and mutant analyses  
  e.g. referenced from `python/geometricSum/mutants_analysis/mutants_detection.py:81–82`.

As with Java, Python mutants are **assumed to be already present** and consistent with the structure described in the paper; this repository only consumes them.

#### `mutants_analysis/`

- `mutants_detection.py` (geometric sum) is the Python analogue of Java’s `MutantAnalysis`:
  - Generates test cases (via phase1 generators) and loads mutants from the `mutants` module  
    `python/geometricSum/mutants_analysis/mutants_detection.py:100–118, 120–142`.
  - Executes all mutants with timeouts, records results per input, and identifies when mutants are killed  
    `python/geometricSum/mutants_analysis/mutants_detection.py:144–179, 180–249`.
  - Classifies mutants into types (**NORMAL**, **EQUIVALENT**, **SUBSUMED**, **ALLKILLED**, **ERROR**, **TIMEOUT**) and iteratively infers subsumption relationships  
    `python/geometricSum/mutants_analysis/mutants_detection.py:258–338`.
  - Computes a greedy maximum independent set over mutants and builds a structured JSON-style report of statistics, subsumption, and mutants-by-type  
    `python/geometricSum/mutants_analysis/mutants_detection.py:340–423, 425–483`.

Other subjects (`incomeTax`, `mortgageRate`) follow the same pattern in spirit, with differences in SUT and domain.

#### `raw_results/` — PSALM vs baselines for Python subjects

Each subject has a script to run PSALM and baseline strategies and log P-measure values.

- Geometric Sum:
  - `python/geometricSum/raw_results/get_raw_results_geometricSum.py` defines  
    `TestCaseGenerationEffectivenessExperiment`, which:
    - Loads configuration and MRs from JSON/YAML.  
      `__init__` at `python/geometricSum/raw_results/get_raw_results_geometricSum.py:33–73`.
    - Dynamically loads a generator class (ART, Random, Partition/PSALM, MT-ART) by scanning the given file for a class with `generate` method  
      `load_test_generator`  
      `python/geometricSum/raw_results/get_raw_results_geometricSum.py:102–128`.
    - Generates MGs either by selecting an MR randomly per source test (phase1) or by sampling from an MG domain (phase2)  
      `generate_metamorphic_groups`  
      `python/geometricSum/raw_results/get_raw_results_geometricSum.py:130–163`.
    - Computes P-measure for a given mutant, generator, and test budget by repeated sampling and MR checks  
      `calculate_p_measure`  
      `python/geometricSum/raw_results/get_raw_results_geometricSum.py:204–251`.
    - Iterates over all mutants, test-case budgets, and repetition counts to produce nested P-measure matrices and optional time consumption stats  
      `run_experiment`  
      `python/geometricSum/raw_results/get_raw_results_geometricSum.py:253–330`.
    - Outputs `P-measure_<method>.json` and `time_consumption_<method>.json` under `RQs/RQ1/raw_results/<program>/<phase>/`  
      `save_results` and `save_time_records`  
      `python/geometricSum/raw_results/get_raw_results_geometricSum.py:332–360`.
  - An `if __name__ == "__main__":` block configures realistic experiment settings for phase1/phase2 but remains a **per-subject driver**, not a unified pipeline entry  
    `python/geometricSum/raw_results/get_raw_results_geometricSum.py:413–475`.

- Income Tax:
  - `python/incomeTax/raw_results/get_raw_results_incomeTax.py` implements a multi-threaded experiment class (`TestCaseGenerationEffectivenessExperimentMT`) inspired by the Java `get_raw_results_multithreaded` design  
    `python/incomeTax/raw_results/get_raw_results_incomeTax.py:1–11, 118–137`.
  - It evaluates PSALM and baseline strategies over mutants in parallel, computing P-measure values and logging to JSON; the structure parallels the geometric sum script but in a multi-threaded style.

- Mortgage Rate:
  - `python/mortgageRate/raw_results/get_raw_results_mortgageRate.py` mirrors the income tax script, providing a multi-threaded experimental driver `TestCaseGenerationEffectivenessExperimentMT` for mortgage-rate mutants  
    `python/mortgageRate/raw_results/get_raw_results_mortgageRate.py:1–15, 105–137`.

#### `utils/`

- Each subject has utilities for:
  - **Path and config management**, e.g.  
    `python/geometricSum/utils/get_path_utils.py`,  
    `python/geometricSum/utils/pharsing_config_utils.py`,  
    with analogues in `incomeTax` and `mortgageRate`.
  - **Metamorphic relation loading**, e.g.  
    `python/geometricSum/utils/load_mrs_utils.py`.
  - **MG domain construction**, e.g.  
    `python/geometricSum/utils/mg_domain_construction_utils.py`, which builds a reusable pool of metamorphic groups used in phase2 experiments.

#### Subject-specific SUTs

- Some Python subjects include SUTs and their mutants in a single file. For example:
  - `python/incomeTax/IncomeTax.py`  
    Contains the original tax function and multiple `main_i` variants acting as mutants, plus a mapping from `main_i` names to functions for experiments  
    `python/incomeTax/IncomeTax.py:10–36`.

---

## 6. Mutant Generation (Conceptual, Tool-based; Refer to Paper)

Mutant generation is **not performed by the code in this repository**:

- Java subjects expect mutant classes to be present under directories such as:
  - `java/src/main/java/paper/pss/exp/<project>/mutants/`
- Python subjects expect mutant functions to be exposed by:
  - `python.<subject>.mutants.mutants.mutants().test_subject`, as used in  
    `python/geometricSum/mutants_analysis/mutants_detection.py:81–82` and the raw-result drivers.

The intended process is:

1. Use external mutation tools (as described in the paper) to generate mutants for the SUTs.
2. Place the resulting mutated source in the directory structure expected by the Java/Python code.
3. Optionally run integration utilities:
   - `RenameMutants` to normalize directory names and add appropriate package statements for Java mutants  
     `java/src/main/java/paper/pss/exp/utils/RenameMutants.java:18–31, 63–80`.
   - `changePackagename` to fix package prefixes for an entire tree of Java mutants  
     `java/src/main/java/paper/pss/exp/utils/changePackagename.java:16–19, 32–63`.

Important properties:

- **The repository does not attempt to store all mutants as a dataset.** Mutants are treated as **experimental inputs** and are expected to be prepared according to the paper.
- The PSALM and baseline experiments assume that mutants exist and **fail fast** or log warnings if they do not.

For details on which external tools and mutation operators are used, please refer to the paper; this repository only provides the **experimental harness** around those mutants.

---

## 7. How the Pieces Fit Together (Conceptual Pipeline)

The overall experimental workflow can be summarized at a high level:

1. **Prepare subject programs and mutants**
   - For each subject (Java or Python), implement:
     - The SUT (e.g., `IncomeTax.main`, geometric sum, mortgage rate computation).
     - Metamorphic relations specific to the SUT’s semantics.
   - Generate mutants externally and integrate them into `mutants/` (Java) or `mutants` modules (Python).
   - Use helpers such as `RenameMutants` / `changePackagename` if necessary for Java integration.

2. **Define PSALM and baseline generators**
   - For **phase1** (source test selection):
     - PSALM is realized via **partition-based** generators (`PartitionGenerator`, `phase1_partition_generator`), which sample proportionally according to partition sizes and ratios  
       e.g. `python/geometricSum/generation/phase1/partition_generator.py:10–27, 56–74`.
     - Baselines include **Random** and **distance-based ART**, implemented in matching generator modules.
   - For **phase2** (metamorphic group selection):
     - Use MG-domain generators (`MGDomainGenerator` in Java/Python) to build a pool of candidate MGs.
     - PSALM and MT-ART variants sample from this MG domain based on partitioning or distance criteria.

3. **Run per-subject experiments to generate raw results**
   - For Java subjects:
     - Use `get_raw_results_multithreaded` per project to evaluate PSALM and baselines across mutants and test-case budgets, writing `P-measure_<strategy>.json` under per-project `raw_results/phase1` and `raw_results/phase2` directories  
       e.g. `java/src/main/java/paper/pss/exp/jackson_project/raw_results/get_raw_results_multithreaded.java:460–479`.
   - For Python subjects:
     - Use `get_raw_results_<subject>.py` to perform the analogous experiments and store results under `RQs/RQ1/raw_results/<program>/<phase>/` or subject-level `raw_results/`.

4. **Compute RQ-level statistics and tables**
   - **RQ1** (PSALM vs Random):
     - `RQ1/RQ1.py` loads `P-measure_partition.json` (PSALM) and `P-measure_random.json` for each project/phase, as configured in `RQ1/config.yaml`.
     - It computes per-mutant and summary statistics (means, Wilcoxon, Vargha–Delaney A12) and writes `RQ1.xlsx`  
       `RQ1/RQ1.py:76–101, 104–223, 226–253`.
     - `RQ1_figure.py` and `RQ1_table.py` post-process the Excel output into figures and LaTeX tables.
   - **RQ2** (PSALM in phase1 vs phase2):
     - `RQ2/RQ2.py` compares PSALM partition results between phases using shared helpers from RQ1  
       `RQ2/RQ2.py:1–18, 58–99, 244–281`.
   - **RQ3** (PSALM vs ART and MT-ART):
     - `RQ3/RQ3.py` loads `P-measure_partition.json` as PSALM and compares it against `P-measure_art.json` (phase1) and `P-measure_mtart.json` (phase2) for specified mutants in `RQ3/config.yaml`  
       `RQ3/RQ3.py:1–22, 99–152`.
     - It generates `RQ3_phase1.xlsx` and `RQ3_phase2.xlsx`, which are then turned into LaTeX tables and figures by `RQ3_figure.py` / `rq3_table.py`  
       `RQ3/rq3_table.py:96–116`.

5. **Mutant-level analysis (optional, supporting)**
   - Java `MutantAnalysis` and Python `mutants_detection.py` perform deeper analysis of the mutant sets (type classification, subsumption, maximum independent sets).
   - These components are **supporting tools** to understand mutant quality and relationships; they are not the core PSALM vs baseline comparison scripts.

**Important:** All of the above steps are driven by per-component `main` methods or `if __name__ == "__main__":` blocks. There is **no single unified entry point** that runs this pipeline end to end. Users are expected to consult both the paper and this code to orchestrate experiments.

---

## 8. Notes on Usage and Reproducibility

This repository should be read as **research code**, not as an off-the-shelf tool:

- There is **no single unified entry point.** Instead:
  - Java experiments are launched per project (e.g., `MutantAnalysis.main`, `get_raw_results_multithreaded.main`).
  - Python experiments are launched per subject or per RQ script (e.g., `get_raw_results_geometricSum.__main__`, `RQ1/RQ1.py.__main__`, etc.).
- The code assumes:
  - Mutant sets are already present and organized as expected by the project-specific loaders.
  - Configuration files (`*.yaml`, `*.json`) match the structure consumed by the code (`partition_num`, `mutants`, `path` fields, etc.; see e.g. `RQ2/config.yaml:1–12`).
  - Long-running experiments (e.g., 1000×50 iterations per configuration) are acceptable in your environment.

Consequences for reproducibility:

- **One-click reproduction is not provided.** To reproduce the paper’s results:
  - You must combine the **paper’s experimental description** with the **code in this repository**.
  - You may need to regenerate mutants with the same external tools and options described in the paper.
  - You may need to adjust file paths, configuration files, and iteration counts to match your environment.
- For reviewers and researchers:
  - The most reliable way to understand and reuse this code is to treat it as a **set of reference implementations** of:
    - PSALM’s proportional sampling strategy (via `partition` generators).
    - Baseline strategies (Random, ART, MT-ART).
    - Mutant-level analysis and RQ-level statistical aggregation.
  - If you wish to adapt PSALM to a new subject program, recommended entry points are:
    - The partition-based generators in `generation/phase1` and `generation/phase2`.
    - The raw-result drivers in `raw_results` (Java or Python).
    - The RQ aggregation scripts in `RQ1/`, `RQ2/`, `RQ3/`.

Whenever behavior or parameters are unclear, **code-level understanding is required**; this README intentionally avoids promising more automation than the code actually provides.

---

## 9. Citation

If you use this repository or build upon PSALM in academic work, please cite the original paper:

> **“PSALM: applying Proportional SAmpLing strategy in Metamorphic testing”**

Please refer to the published version of the paper for the authoritative citation details (authors, venue, year, DOI, etc.).

A generic BibTeX template (to be completed with the actual publication data) is:

```bibtex
@inproceedings{psalm,
  title     = {PSALM: applying Proportional SAmpLing strategy in Metamorphic testing},
  author    = {...},
  booktitle = {...},
  year      = {...},
  publisher = {...}
}
```

Replace the placeholder fields with the correct information from the official publication.

---

## 10. License

This project is released under the **MIT License**.

See `LICENSE` for the full text:  
`LICENSE:1–21`.
